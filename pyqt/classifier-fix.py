# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QObject, QThread, pyqtSignal
from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QFileDialog

import pickle
import tensorflow as tf
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import numpy as np
import cv2

from os import listdir
from osgeo import gdal
from scipy import stats
from xgboost import XGBClassifier
from tensorflow.keras import layers, models

class Ui_MainWindow(object):

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(505, 383)

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.editIn = QtWidgets.QTextEdit(self.centralwidget)
        self.editIn.setGeometry(QtCore.QRect(90, 40, 311, 21))
        self.editIn.setObjectName("editIn")

        self.editInFile = QtWidgets.QPushButton(self.centralwidget)
        self.editInFile.setGeometry(QtCore.QRect(410, 40, 31, 23))
        self.editInFile.setObjectName("editInFile")

        self.editOut = QtWidgets.QTextEdit(self.centralwidget)
        self.editOut.setGeometry(QtCore.QRect(90, 90, 311, 21))
        self.editOut.setObjectName("editOut")

        self.editoutFile = QtWidgets.QPushButton(self.centralwidget)
        self.editoutFile.setGeometry(QtCore.QRect(410, 90, 31, 21))
        self.editoutFile.setObjectName("editoutFile")

        self.checkBoxShImg = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBoxShImg.setGeometry(QtCore.QRect(90, 130, 121, 21))
        self.checkBoxShImg.setObjectName("checkBoxShImg")

        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(290, 260, 141, 31))
        self.pushButton.setObjectName("pushButton")

        self.progressBar = QtWidgets.QProgressBar(self.centralwidget)
        self.progressBar.setGeometry(QtCore.QRect(90, 210, 351, 21))
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")

        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(90, 20, 51, 16))
        self.label.setObjectName("label")

        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(90, 70, 51, 16))
        self.label_2.setObjectName("label_2")

        self.ProgLabel = QtWidgets.QLabel(self.centralwidget)
        self.ProgLabel.setGeometry(QtCore.QRect(100, 210, 310, 21))
        self.ProgLabel.setObjectName("ProgLabel")

        MainWindow.setCentralWidget(self.centralwidget)

        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 505, 21))
        self.menubar.setObjectName("menubar")

        MainWindow.setMenuBar(self.menubar)

        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")

        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.addedUI()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.editInFile.setText(_translate("MainWindow", "..."))
        self.editoutFile.setText(_translate("MainWindow", "..."))
        self.checkBoxShImg.setText(_translate("MainWindow", "show image"))
        self.pushButton.setText(_translate("MainWindow", "process"))
        self.label.setText(_translate("MainWindow", "Input file"))
        self.label_2.setText(_translate("MainWindow", "Output file"))
        self.ProgLabel.setText(_translate("MainWindow", "None"))

        self.msg = "None"
        self.outfile = ""
    
    def addedUI(self):
        self.Img = None

        self.infile = ""
        self.outfile = ""

        self.editIn.setReadOnly(True)
        self.editOut.setReadOnly(True)

        self.editInFile.clicked.connect(self.editInput)
        self.editoutFile.clicked.connect(self.editOutput)
        self.pushButton.clicked.connect(self.classify)
    
    def checkShow(self):
        if self.checkBoxShImg.isChecked():
            worker = self.WorkerShowImg()
            self.runHeavy(worker)
    
    def editInput(self):
        self.infile = str(QFileDialog.getExistingDirectory(MainWindow, "Select Directory"))
        self.editIn.setPlainText(self.infile)
        
        onFinish = [self.checkShow]

        worker = self.WorkerLoad1C()
        worker.infile = self.infile
        self.runHeavy(worker, onFinish)
    
    def editOutput(self):
        self.outfile = str(QFileDialog.getExistingDirectory(MainWindow, "Select Directory"))
        self.editOut.setPlainText(self.outfile)

    def unlockButtons(self):
        self.pushButton.setEnabled(True)
        self.editInFile.setEnabled(True)
        self.editoutFile.setEnabled(True)
        self.checkBoxShImg.setEnabled(True)
    
    def runHeavy(self, worker, onFinish = list()):
        self.thread = QThread()
        self.worker = worker
        self.worker.moveToThread(self.thread)

        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.thread.quit)
        self.worker.progress.connect(self.reportProgress)
        self.thread.finished.connect(self.thread.deleteLater)

        self.worker.mainWin = self

        self.thread.finished.connect(self.unlockButtons)
        for func in onFinish:
            self.thread.finished.connect(func)

        self.thread.start()
        self.pushButton.setEnabled(False)
        self.editInFile.setEnabled(False)
        self.editoutFile.setEnabled(False)
        self.checkBoxShImg.setEnabled(False) 
    
    def classify(self):
        worker = self.WorkerClassify()
        self.runHeavy(worker)

    def reportProgress(self, n):
        self.ProgLabel.setText(self.msg)
        self.progressBar.setProperty("value", n)

    class WorkerClassify(QObject):
        finished = pyqtSignal()
        progress = pyqtSignal(int)

        def show_img(self, img):
            VIS = np.zeros((img[:,:, 0].shape[0], img[:,:, 0].shape[1], 3), dtype=np.float32)
            VIS[:,:,0] = img[:,:,3]
            VIS[:,:,1] = img[:,:,2]
            VIS[:,:,2] = img[:,:,1]
            
            mean, sigma = np.mean(VIS), np.std(VIS)
            conf_int = stats.norm.interval(0.95, loc=mean, scale=sigma)
            
            VIS = VIS / conf_int[1]
            
            return VIS

        def run(self):
            scalers = list()

            self.mainWin.msg = "loading scalers"
            self.progress.emit(0)

            with open('img.pickle', 'wb') as file:
                pickle.dump(self.mainWin.Img, file, protocol=4)

            with open('scalers.pickle', 'rb') as file:
                scalers = pickle.load(file)

            self.mainWin.msg = "normalizing data"
            self.progress.emit(10)

            scaled = np.zeros((self.mainWin.Img.shape[0], self.mainWin.Img.shape[1], 13), dtype=np.float32)
            for channel in range(13):
                scaled[:, :, channel] = scalers[channel].transform(self.mainWin.Img[:, :, channel].reshape(-1, 1)).reshape(self.mainWin.Img.shape[0], self.mainWin.Img.shape[1])
            SHAPE = scaled.shape

            self.mainWin.msg = "splitting into patches"
            self.progress.emit(20)
            
            del self.mainWin.Img

            patches = list()
            for x in range(0, scaled.shape[0] - 64, 64):
                if x == scaled.shape[0] - 64:
                    tmp = scaled[-64:, :, :]
                else:
                    tmp = scaled[x : x+64, :, :]
                for y in range(0, scaled.shape[1] - 64, 64):
                    if y == scaled.shape[1] - 64:
                        patches.append(tmp[:, -64:, :])
                    else:
                        patches.append(tmp[:, y : y + 64, :])

            del scaled, tmp
            patches = np.array(patches)

            self.mainWin.msg = "loading model"
            self.progress.emit(30)

            model = models.Sequential()
            model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 13)))
            model.add(layers.BatchNormalization())
            model.add(layers.Conv2D(32, (5, 5), strides=2, activation='relu', padding='same'))
            model.add(layers.BatchNormalization())
            model.add(layers.Dropout(0.3))
            model.add(layers.Conv2D(64, (3, 3), activation='relu'))
            model.add(layers.BatchNormalization())
            model.add(layers.Conv2D(64, (5, 5),strides = 2,padding='same', activation='relu'))
            model.add(layers.BatchNormalization())
            model.add(layers.Dropout(0.3))
            model.add(layers.Conv2D(92, (3, 3), activation='relu'))
            model.add(layers.BatchNormalization())
            model.add(layers.Conv2D(92, (5, 5), strides = 2,padding='same', activation='relu'))
            model.add(layers.BatchNormalization())
            model.add(layers.Dropout(0.3))
            model.add(layers.Flatten())
            model.add(layers.Dense(256, activation='relu'))
            model.add(layers.BatchNormalization())
            model.add(layers.Dropout(0.3))
            model.add(layers.Dense(10, activation='softmax'))

            model.compile(optimizer='adam',
                        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
                        metrics=['accuracy'])
            
            model.load_weights('tf-CNN-97%.ckpt')
            model.pop()
            model.pop()
            model.pop()
            model.pop()
            model.summary()

            self.mainWin.msg = "processing patches Conv"
            self.progress.emit(40)

            X_conv = model.predict(patches)

            del patches

            self.mainWin.msg = "loading boost"
            self.progress.emit(50)

            with open('xgboost-conv-98,1%.pickle', 'rb') as file:
                model = pickle.load(file)
            
            self.mainWin.msg = "processing patches boost"
            self.progress.emit(60)

            res = model.predict(X_conv)

            del X_conv

            with open('img.pickle', 'rb') as file:
                    self.mainWin.Img = pickle.load(file)

            colors = np.array(
                    [[165,42,42], #Annual Crop
                    [0, 106, 0], #Forest
                    [0, 255, 0], #HerbaceousVegetation
                    [220, 220, 220], #Highway
                    [255,255,0], #Industrial
                    [218,165,32], #Pasture
                    [0,250,154], #PermanentCrop
                    [255, 0, 0], #Residential
                    [0, 200, 255], #River
                    [0, 0, 255], #SeaLake
                    ])
            
            color_names = ["Annual Crop",
                            "Forest",
                            "HerbaceousVegetation",
                            "Highway",
                            "Industrial",
                            "Pasture",
                            "PermanentCrop",
                            "Residential",
                            "River",
                            "SeaLake"]
            
            handles = [mpatches.Patch(color=colors[i]/255, label=color_names[i]) for i in range(10)]
            
            self.mainWin.msg = "mapping colors"
            self.progress.emit(70)
            
            color_map = np.zeros((SHAPE[0], SHAPE[1], 3), dtype=np.uint16)
            index = 0
            for x in range(0, self.mainWin.Img.shape[0] - 64, 64):
                for y in range(0, self.mainWin.Img.shape[1] - 64, 64):
                    color_map[x:x+64,y:y+64,:] = colors[res[index]]
                    index += 1
            
            self.mainWin.msg = "making figure"
            self.progress.emit(80)
            
            fig = plt.figure(figsize=(20, 20))
            tmp = self.show_img(self.mainWin.Img)
            plt.imshow(tmp)
            plt.imshow(color_map, alpha=.25)
            plt.legend(handles=handles)

            self.mainWin.msg = "saving classified image"
            self.progress.emit(90)

            fig.savefig(self.mainWin.outfile + "\\classified.png")
            self.progress.emit(100)
            self.finished.emit()

    class WorkerShowImg(QObject):
        finished = pyqtSignal()
        progress = pyqtSignal(int)

        def show_img(self, img):
            VIS = np.zeros((img[:,:, 0].shape[0], img[:,:, 0].shape[1], 3), dtype=np.float32)
            VIS[:,:,0] = img[:,:,3]
            VIS[:,:,1] = img[:,:,2]
            VIS[:,:,2] = img[:,:,1]
            
            mean, sigma = np.mean(VIS), np.std(VIS)
            conf_int = stats.norm.interval(0.95, loc=mean, scale=sigma)
            
            VIS = VIS / conf_int[1]
            
            return VIS

        def run(self):
            self.mainWin.msg = "Converting to rgb"
            self.progress.emit(0)
            
            VIS = self.show_img(self.mainWin.Img)

            self.mainWin.msg = "Plotting"
            self.progress.emit(33)
            fig = plt.figure(figsize=(20, 20))
            plt.imshow(VIS)

            self.mainWin.msg = "Saving to " + self.mainWin.outfile + "\\satellite image rgb.png"
            self.progress.emit(66)
            fig.savefig(self.mainWin.outfile + "\\satellite image rgb.png")

            self.progress.emit(100)
            self.finished.emit()
    
    class WorkerLoad1C(QObject):
        finished = pyqtSignal()
        progress = pyqtSignal(int)

        def run(self):

            path = self.infile
            path += "\\GRANULE"
            path += "\\" + listdir(path)[0] + "\\IMG_DATA"

            bands = list()
            ind = 0
            for i in range(13):
                band_file = listdir(path)[i]
                self.mainWin.msg = "reading " + band_file
                self.progress.emit(5*ind/1.3)

                band = gdal.Open(path + "\\" + band_file, gdal.GA_ReadOnly)
                bands.append(band.GetRasterBand(1).ReadAsArray())
                ind+=1

            self.progress.emit(50)
            
            shape = bands[1].shape
            full_image = np.zeros((shape[0], shape[1], 13), dtype=np.float32)

            for i in range(13):
                band = bands[i]
                self.mainWin.msg = "Resizing bands {0}/13".format(i + 1)
                self.progress.emit((5*(i+1) + 65)/1.3)

                resized = cv2.resize(band[:, :], shape)
                full_image[:, :, i] = resized

            self.progress.emit(100)
            
            self.mainWin.Img = full_image

            self.finished.emit()
            


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
